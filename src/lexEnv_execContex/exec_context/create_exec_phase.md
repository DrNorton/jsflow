# Этапы создания и выполнения контекста

Разберем что в действительности делает JavaScript-движок для создания контекста выполнения. Этот процесс проходит в два этапа:

1. Этап создания
2. Этап выполнения

## Создание контекста выполнения и "всплытие"

Этап создания - это этап, в котором JavaScript-движок вызвал функцию, но само ее выполнение еще не началось. На этапе создания контекста JavaScript-движок находится на фазе компиляции, то есть он просматривает код этой функцию для последующей его компиляции.

Именно вследствие выполнения этапа создания следующий код будет работать:

```javascript
showText();
console.log(value);

var value = "Переменная value";

function showText() {
 console.log("Вызов функции showText()");
}
```

Результат выполнения кода:

```javascript
> "Вызов функции showText()"
> "Переменная value"
```

Это может показаться неожиданным поведением программы, так как вызов функции `showText()` и обращение к переменной `value` происходит до их объявления в коде. Но в JavaScript это работает потому, что на этапе создания контекста, до выполнения функции, JavaScript-движок исследует код и формирует контекст, который содержит в себе указатель на текущее Лексическое окружение, связанное с выполняемым кодом.

![Указатель на Лексическое Окружение в Контексте выполнения](images/execCont_lexEnv.png)

В предыдущей части говорилось, что лексическое окружение содержит в себе Запись Окружения, но то, что она из себя представляет, мы рассматривали на этапе уже выполненного кода. Например:

```javascript
// globalEnvironment
// outer: null - нет родительского окружения
// environmentRecord = {x: 10}
var x = 10;
// Выполнение уже на этой строке.
```

Хотя в действительности, Запись Окружения меняется в течение выполнения кода. Она создаётся и начинает формироваться на этапе создания контекста,. В неё помещаются все объявленные в коде переменные и функции, тем самым для них резервируется место в памяти еще до выполнения первой строчки кода.

Вот как выглядит запись окружения на этапе создания контекста выполнения

```javascript
// выполнение еще не началось

// globalEnvironment
// outer: null - нет родительского окружения

// environmentRecord = {x: undefined}

var x = 10;
```

Здесь важно заметить, что на этапе создания контекста, переменные и функциональные выражения, такие как:

```javascript
var x = 10;
var func = function(params) {
 // тело функции
};
```

не инициализируется указанным значениями, а попадают в запись окружения со значением `undefined`.

```javascript
// выполнение еще не началось

// globalEnvironment
// outer: null - нет родительского окружения

// environmentRecord = {x: undefined, func: undefined}

var x = 10;
var func = function(params) {
 // тело функции
};
```

Это происходит потому, что сам код еще не выполняется, и никаких операций присваиваний еще не произошло. JavaScript-движок лишь просканировал код и сформировал запись окружения из имен объявленных переменных и функций. Исключением являются обычные объявления функций, такие как:

```javascript
function name(params) {
 // инструкции...
}
```

Они целиком, вместе с телом функции и встроенными свойствами, помещаются в запись окружения

```javascript
// выполнение еще не началось

// globalEnvironment
// outer: null - нет родительского окружения

// environmentRecord = {name: function name(params){...}}

function name(params) {
 // инструкции...
}
```

Именно из-за формирования записи окружения и выделения памяти под переменные до выполнения кода к ним можно обращаться до их объявления в программе. Такое поведения называется **"всплытие"** или **hoisting**. К сожалению, в некоторых ресурсах всплытие описывают так, что объявление переменной или функции физически поднимается в начало вашего кода, хотя в действительности это не так. На самом же деле, объявления переменных остаются в коде на том же месте, где вы их объявили, только память под них выделяется с самого начала, еще до выполнения кода.

Однако, важно обратить внимание на то, что для переменных `let` и `const` есть некоторые отличия от `var` переменных в механизме всплытия. Например, если обратиться к переменным `let` и `const` до их объявления, то возникнет ошибка `ReferenceError`, в отличие от переменной `var`, значение которой в таком случае отобразится как `undefined`.

```javascript
console.log(foo); // undefined
console.log(pi); // Uncaught ReferenceError: pi is not defined
console.log(bar); // Uncaught ReferenceError: bar is not defined
var foo = 2;
const pi = 3.14;
let bar = 2;
```

Такая ошибка `ReferenceError` из-за попытки получить или установить значение `let` или `const` переменной до её объявления называется ошибкой **"Временной мертвой зоны" (Temporal Dead Zone (TDZ) error)**.

В некоторых источниках можно встретить утверждение, что переменные `let` и `const` вообще не всплывают, на самом деле это не так. Они также попадают в запись окружения как и `var` переменные при создании контекста.

```javascript
// выполнение еще не началось

// globalEnvironment
// outer: null - нет родительского окружения

// environmentRecord = {foo: undefined, pi: undefined, bar: undefined}

console.log(foo); // undefined
console.log(pi); // Uncaught ReferenceError: pi is not defined
console.log(bar); // Uncaught ReferenceError: bar is not defined
var foo = 2;
const pi = 3.14;
let bar = 2;
```

Только к ним нельзя получить доступ для чтения или записи до тех пор, пока не будет выполнена строка с объявлением этой переменной на этапе выполнения контекста. Механизм, обеспечивающий такое отличие доступа к переменным `let` и `const` от `var` возникает детально будет рассмотрен в следующий части, а сейчас приведем примеры работы временной мертвой зоны.

```javascript
{
 // Заход в новую блочную область видимости
 // Начало временной мертвой зоны

 // Попытки обращения к переменной tmp до её объявления (запись в неё значения и чтения этого значения)
 tmp = "abc"; // Uncaught ReferenceError: tmp is not defined
 console.log(tmp); // Uncaught ReferenceError: tmp is not defined

 let tmp; // конец временной мертвой зоны, переменная tmp инициализируется значением undefined
 console.log(tmp); // undefined

 tmp = 123;
 console.log(tmp); // 123
}
```

Механизм временной мертвой зоны базируется именно на контексте выполнения. В следующем примере видно, что _временная мертвая зона заканчивается именно тогда, когда **само выполнение кода** доберется до объявления переменной_. И выполнение кода дальше пройдет без ошибок несмотря на то, что сама функция `func`, где запрашивается переменная, написана (определена лексически) раньше объявления `let myVar = 3`.

```javascript
{
 // Заход в новую блочную область видимости
 // Начало временной мертвой зоны

 const func = function() {
  console.log(myVar); // 3
 };

 // Здесь действует временная мертвая зона
 // и обращение к переменной myVar вызовет ошибку ReferenceError

 let myVar = 3; // конец временной мертвой зоны
 func(); // вызов функции после окончания временной мертвой зоны
}
```

Еще одним интересным моментом является поведение оператора `typeof` при временной мертвой зоне. Оператор `typeof` возвращает тип данных переменной и часто используется для проверки существования глобальных переменных.

```javascript
console.log(typeof foo); // Uncaught ReferenceError: foo is not defined
console.log(typeof aVariableThatDoesNotExist); // undefined
let foo;
```

В случае с необъявленной переменной `aVariableThatDoesNotExist`, которой не существует, оператор покажет `undefined`. А в случае с объявленной `foo` возникнет ошибка, так как эта переменная объявлена, но запрошена во время действия временной мертвой зоны.

Вообще, как можно заметить из предыдущих примеров этой части курса,чтобы код было легче читать и поддерживать, а также для сокращения возможных ошибок, не стоит полагаться на всплытие и лучше сначала объявлять переменные, а потом их использовать. Так код станет яснее и вести разработку и поддерживать код будет намного проще.

## Выполнение кода. Однопоточность и синхронное выполнение

После этапа создания контекста начинается второй этап - выполнение кода. Написанный код, построчно интерпретируется и выполняется JavaScript-движком.

Рассмотрим пример выполнения кода:

```javascript
console.log("Первое обращение: " + text);

var text = "Всем привет!";

console.log("Второе обращение: " + text);
```

Результат выполнения кода:

```javascript
> "Первое обращение: undefined"
> "Второе обращение: Всем привет!"
```

В данном случае, на этапе выполнения, первое обращение не вызовет ошибки и выведет `undefined` именно из-за пройденного этапа создания контекста выполнения, на котором код был целиком исследован/обработан JavaScript-движком, в результате чего объявленная в нём переменная `text` добавилась в запись окружения и под неё выделилось место в памяти. Иными словами произошло "всплытие этой переменной". Но само значение этой переменной еще не было присвоено, это произойдет только после выполнения строки с объявлением переменной, где ей присваивается определенное значение — "Всем привет!". Поэтому при первом обращении будет выведено `undefined`, а при втором выведется уже заданное при объявлении значение переменной.

```javascript
console.log("Первое обращение: " + text); // <-- при выполнении этой строки environmentRecord = {text: undefined}

var text = "Всем привет!"; // <-- выполнение этой строки меняет environmentRecord на {text: "Всем привет!"}

console.log("Второе обращение: " + text); // <-- при выполнении этой строки environmentRecord = {text: "Всем привет!"}
```

При разработке на JavaScript необходимо понимать, что весь код выполняется синхронно в одном потоке выполнения. Это значит, что инструкции программы выполняется поочередно друг за другом, выполнение следующей инструкции начинается только после выполнения текущей, тем самым в определенный момент времени может выполняться только одна инструкция/команда. При такой синхронной модели невозможно приостанавливать выполнение задачи, чтобы в промежутке выполнить другую.

Схематично это можно изобразить так:

![Однопоточное выполнение задач](images/thread.png)

Если рассматривать среду браузера, то в нём может много потоков выполнения, отвечающих за рабочие процессы браузера, но с точки зрения выполнения в нём программы JavaScript, то она обрабатывается и выполняется в браузере в одном потоке. Поэтому если в коде JavaScript есть определенная операция, выполнение которой займет много времени, то она будет блокировать выполнение всех дальнейших инструкций, которые будут ожидать её окончания.

~~Например: цикл, а также другой пример блокирующей операции, это alert~~

## Задачи...

~~https://medium.freecodecamp.org/function-hoisting-hoisting-interview-questions-b6f91dbc2be8~~
